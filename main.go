// @title Screensaver API
// @version 1.0
// @description API for controlling the screensaver daemon
// @host localhost:8087
// @BasePath /api

package main

import (
	"bufio"
	"encoding/json"
	"flag"
	"fmt"
	"html/template"
	"io"
	"log"
	"net/http"
	"os"
	"os/exec"
	"os/signal"
	"path/filepath"
	"strings"
	"sync"
	"syscall"
	"time"

	httpSwagger "github.com/swaggo/http-swagger/v2"
	_ "github.com/rob121/piscreensaver/docs" // docs is generated by Swag CLI
)

// multiWriter lets us log to multiple outputs when --debug is on
type multiWriter struct {
	ws [](*os.File)
}

func (m *multiWriter) Write(p []byte) (int, error) {
	for _, w := range m.ws {
		if _, err := w.Write(p); err != nil {
			return 0, err
		}
	}
	return len(p), nil
}

func ioMultiWriter(writers ...*os.File) *multiWriter {
	return &multiWriter{writers}
}

// splitArgs splits a space-separated arg string into []string
// (simple splitter; no shell quoting/escaping support)
func splitArgs(s string) []string {
	return strings.Fields(s)
}

// inBlankWindow returns true if "now" falls within the configured blank window.
// Handles normal windows (start < end) and overnight windows (start > end).
// If blankStart == blankEnd, returns false (treat as disabled).
func inBlankWindow(now time.Time, blankStart, blankEnd time.Duration) bool {
	if blankStart == blankEnd {
		return false
	}
	today := time.Duration(now.Hour())*time.Hour +
		time.Duration(now.Minute())*time.Minute +
		time.Duration(now.Second())*time.Second

	if blankStart < blankEnd {
		return today >= blankStart && today < blankEnd
	}
	return (today >= blankStart) || (today < blankEnd)
}

// parseHHMM parses "23:00" into a Duration since start of day.
func parseHHMM(v string) (time.Duration, error) {
	v = strings.TrimSpace(v)
	if v == "" {
		return 0, nil
	}
	parts := strings.Split(v, ":")
	if len(parts) != 2 {
		return 0, fmt.Errorf("bad time %q", v)
	}
	hh := parts[0]
	mm := parts[1]

	h, err := time.Parse("15", hh)
	if err != nil {
		return 0, err
	}
	m, err := time.Parse("04", mm)
	if err != nil {
		return 0, err
	}

	d := time.Duration(h.Hour())*time.Hour + time.Duration(m.Minute())*time.Minute
	return d, nil
}

// imageExtensions lists valid image file extensions
var imageExtensions = map[string]bool{
	".jpg":  true,
	".jpeg": true,
	".png":  true,
	".gif":  true,
	".bmp":  true,
	".webp": true,
}

// isImageFile checks if a file has an image extension
func isImageFile(filename string) bool {
	ext := strings.ToLower(filepath.Ext(filename))
	return imageExtensions[ext]
}

// isImageFileOrDisabled checks if a file is an image (including .disabled files)
func isImageFileOrDisabled(filename string) bool {
	// Remove .disabled extension if present
	name := filename
	if strings.HasSuffix(name, ".disabled") {
		name = strings.TrimSuffix(name, ".disabled")
	}
	return isImageFile(name)
}

// ScreensaverState manages the screensaver state for API access
type ScreensaverState struct {
	mu            sync.RWMutex
	startSaver    func()
	stopSaver     func(string)
	inBlankWindow func() bool
}

// webServer handles the HTTP web interface
func webServer(imageDir, port string, state *ScreensaverState) error {
	if port == "" {
		return nil // Disabled
	}

	mux := http.NewServeMux()

	// Register specific routes BEFORE the catch-all root handler
	// This ensures they take precedence

	// Swagger UI (must be registered before root handler)
	mux.HandleFunc("/swagger/", httpSwagger.Handler(
		httpSwagger.URL("/swagger/doc.json"),
	))

	// API endpoints for screensaver control
	mux.HandleFunc("/api/startscreensaver", func(w http.ResponseWriter, r *http.Request) {
		startScreensaver(w, r, state)
	})

	mux.HandleFunc("/api/stopscreensaver", func(w http.ResponseWriter, r *http.Request) {
		stopScreensaver(w, r, state)
	})

	// Handler for serving image files (including .disabled files)
	mux.HandleFunc("/images/", func(w http.ResponseWriter, r *http.Request) {
		imageName := strings.TrimPrefix(r.URL.Path, "/images/")
		// Basic security: prevent directory traversal
		if strings.Contains(imageName, "..") || strings.Contains(imageName, "/") {
			http.Error(w, "Invalid path", http.StatusBadRequest)
			return
		}
		imagePath := filepath.Join(imageDir, imageName)
		
		// Check if file exists
		if _, err := os.Stat(imagePath); os.IsNotExist(err) {
			http.Error(w, "File not found", http.StatusNotFound)
			return
		}
		
		// Determine content type based on actual image extension (before .disabled)
		nameForType := imageName
		if strings.HasSuffix(nameForType, ".disabled") {
			nameForType = strings.TrimSuffix(nameForType, ".disabled")
		}
		if isImageFile(nameForType) {
			ext := strings.ToLower(filepath.Ext(nameForType))
			switch ext {
			case ".jpg", ".jpeg":
				w.Header().Set("Content-Type", "image/jpeg")
			case ".png":
				w.Header().Set("Content-Type", "image/png")
			case ".gif":
				w.Header().Set("Content-Type", "image/gif")
			case ".bmp":
				w.Header().Set("Content-Type", "image/bmp")
			case ".webp":
				w.Header().Set("Content-Type", "image/webp")
			}
		}
		
		http.ServeFile(w, r, imagePath)
	})

	// Handler for the main page (list images + upload form)
	mux.HandleFunc("/", func(w http.ResponseWriter, r *http.Request) {
		// Skip swagger paths - they should be handled by swagger handler
		if strings.HasPrefix(r.URL.Path, "/swagger") {
			http.NotFound(w, r)
			return
		}

		if r.Method == http.MethodPost {
			// Handle file upload
			err := r.ParseMultipartForm(32 << 20) // 32MB max
			if err != nil {
				http.Error(w, fmt.Sprintf("Error parsing form: %v", err), http.StatusBadRequest)
				return
			}

			files := r.MultipartForm.File["images"]
			uploaded := 0
			for _, fileHeader := range files {
				func() {
					file, err := fileHeader.Open()
					if err != nil {
						log.Printf("Error opening uploaded file: %v", err)
						return
					}
					defer file.Close()

					// Check if it's an image
					if !isImageFile(fileHeader.Filename) {
						log.Printf("Skipping non-image file: %s", fileHeader.Filename)
						return
					}

					// Create destination file
					dstPath := filepath.Join(imageDir, fileHeader.Filename)
					dst, err := os.Create(dstPath)
					if err != nil {
						log.Printf("Error creating file %s: %v", dstPath, err)
						return
					}
					defer dst.Close()

					// Copy file
					if _, err := io.Copy(dst, file); err != nil {
						log.Printf("Error copying file: %v", err)
						dst.Close()
						os.Remove(dstPath)
						return
					}

					uploaded++
					log.Printf("Uploaded image: %s", fileHeader.Filename)
				}()
			}

			// Redirect to refresh the page after upload
			http.Redirect(w, r, "/", http.StatusSeeOther)
			return
		}

		// List images in directory
		entries, err := os.ReadDir(imageDir)
		if err != nil {
			http.Error(w, fmt.Sprintf("Error reading directory: %v", err), http.StatusInternalServerError)
			return
		}

		var activeImages []string
		var disabledImages []string
		for _, entry := range entries {
			name := entry.Name()
			if !entry.IsDir() && isImageFileOrDisabled(name) {
				if strings.HasSuffix(name, ".disabled") {
					disabledImages = append(disabledImages, name)
				} else {
					activeImages = append(activeImages, name)
				}
			}
		}
		
		// Create image data structure for template
		type pageData struct {
			Active   []string
			Inactive []string
		}
		data := pageData{
			Active:   activeImages,
			Inactive: disabledImages,
		}

		// Render HTML template
		tmpl := `<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Screensaver Image Manager</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <style>
        .image-thumb {
            width: 100%;
            height: 200px;
            object-fit: cover;
        }
        .image-card {
            transition: transform 0.2s;
            position: relative;
        }
        .image-card:hover {
            transform: scale(1.05);
        }
        .disable-btn {
            position: absolute;
            bottom: 5px;
            right: 5px;
            background-color: rgba(220, 53, 69, 0.9);
            color: white;
            border: none;
            border-radius: 50%;
            width: 30px;
            height: 30px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            font-weight: bold;
            z-index: 10;
            transition: background-color 0.2s;
        }
        .disable-btn:hover {
            background-color: rgba(220, 53, 69, 1);
        }
        .disabled-image {
            opacity: 0.5;
            filter: grayscale(100%);
        }
        .enable-btn {
            position: absolute;
            bottom: 5px;
            right: 5px;
            background-color: rgba(40, 167, 69, 0.9);
            color: white;
            border: none;
            border-radius: 50%;
            width: 30px;
            height: 30px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            font-weight: bold;
            z-index: 10;
            transition: background-color 0.2s;
        }
        .enable-btn:hover {
            background-color: rgba(40, 167, 69, 1);
        }
    </style>
</head>
<body>
    <div class="container mt-4">
        <h1 class="mb-4">Screensaver Image Manager</h1>
        
        <div class="card mb-4">
            <div class="card-header">
                <h5 class="mb-0">Upload New Images</h5>
            </div>
            <div class="card-body">
                <form method="POST" enctype="multipart/form-data">
                    <div class="mb-3">
                        <label for="images" class="form-label">Select images to upload (multiple files allowed)</label>
                        <input type="file" class="form-control" id="images" name="images" multiple accept="image/*" required>
                    </div>
                    <button type="submit" class="btn btn-primary">Upload Images</button>
                </form>
            </div>
        </div>

        <h2 class="mb-3">Active ({{len .Active}})</h2>
        {{if gt (len .Active) 0}}
        <div class="row mb-5">
            {{range .Active}}
            <div class="col-md-4 col-sm-6 mb-4">
                <div class="card image-card">
                    <div style="position: relative;">
                        <img src="/images/{{.}}" class="card-img-top image-thumb" alt="{{.}}">
                        <form method="POST" action="/disable/{{.}}" style="position: absolute; bottom: 5px; right: 5px; margin: 0;" onclick="event.stopPropagation();">
                            <button type="submit" class="disable-btn" title="Disable image">×</button>
                        </form>
                    </div>
                    <div class="card-body">
                        <p class="card-text text-truncate"><a href="/images/{{.}}" target="_blank">{{.}}</a></p>
                    </div>
                </div>
            </div>
            {{end}}
        </div>
        {{else}}
        <div class="alert alert-info mb-5" role="alert">
            No active images found.
        </div>
        {{end}}

        <h2 class="mb-3">In-Active ({{len .Inactive}})</h2>
        {{if gt (len .Inactive) 0}}
        <div class="row">
            {{range .Inactive}}
            <div class="col-md-4 col-sm-6 mb-4">
                <div class="card image-card disabled-image">
                    <div style="position: relative;">
                        <img src="/images/{{.}}" class="card-img-top image-thumb" alt="{{.}}">
                        <form method="POST" action="/enable/{{.}}" style="position: absolute; bottom: 5px; right: 5px; margin: 0;" onclick="event.stopPropagation();">
                            <button type="submit" class="enable-btn" title="Enable image">✓</button>
                        </form>
                    </div>
                    <div class="card-body">
                        <p class="card-text text-truncate"><a href="/images/{{.}}" target="_blank">{{.}}</a></p>
                    </div>
                </div>
            </div>
            {{end}}
        </div>
        {{else}}
        <div class="alert alert-info" role="alert">
            No inactive images found.
        </div>
        {{end}}
    </div>
    <script>
        // Prevent image click when clicking the disable/enable button
        document.addEventListener('click', function(e) {
            if (e.target.classList.contains('disable-btn') || e.target.closest('.disable-btn') ||
                e.target.classList.contains('enable-btn') || e.target.closest('.enable-btn')) {
                e.stopPropagation();
            }
        });
    </script>
</body>
</html>`

		t, err := template.New("index").Parse(tmpl)
		if err != nil {
			http.Error(w, fmt.Sprintf("Error parsing template: %v", err), http.StatusInternalServerError)
			return
		}

		if err := t.Execute(w, data); err != nil {
			http.Error(w, fmt.Sprintf("Error executing template: %v", err), http.StatusInternalServerError)
			return
		}
	})

	// Handler for disabling an image (renames it with .disabled extension)
	mux.HandleFunc("/disable/", func(w http.ResponseWriter, r *http.Request) {
		if r.Method != http.MethodPost {
			http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
			return
		}
		
		imageName := strings.TrimPrefix(r.URL.Path, "/disable/")
		// Basic security: prevent directory traversal
		if strings.Contains(imageName, "..") || strings.Contains(imageName, "/") || strings.HasSuffix(imageName, ".disabled") {
			http.Error(w, "Invalid path", http.StatusBadRequest)
			return
		}
		
		// Verify it's an image file
		if !isImageFile(imageName) {
			http.Error(w, "Not an image file", http.StatusBadRequest)
			return
		}
		
		oldPath := filepath.Join(imageDir, imageName)
		newPath := oldPath + ".disabled"
		
		// Check if source file exists
		if _, err := os.Stat(oldPath); os.IsNotExist(err) {
			http.Error(w, "File not found", http.StatusNotFound)
			return
		}
		
		// Rename the file
		if err := os.Rename(oldPath, newPath); err != nil {
			log.Printf("Error disabling image %s: %v", imageName, err)
			http.Error(w, fmt.Sprintf("Error disabling image: %v", err), http.StatusInternalServerError)
			return
		}
		
		log.Printf("Disabled image: %s -> %s", imageName, newPath)
		http.Redirect(w, r, "/", http.StatusSeeOther)
	})

	// Handler for enabling an image (removes .disabled extension)
	mux.HandleFunc("/enable/", func(w http.ResponseWriter, r *http.Request) {
		if r.Method != http.MethodPost {
			http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
			return
		}
		
		imageName := strings.TrimPrefix(r.URL.Path, "/enable/")
		// Basic security: prevent directory traversal
		if strings.Contains(imageName, "..") || strings.Contains(imageName, "/") {
			http.Error(w, "Invalid path", http.StatusBadRequest)
			return
		}
		
		// Verify it's a disabled image file
		if !strings.HasSuffix(imageName, ".disabled") {
			http.Error(w, "File is not disabled", http.StatusBadRequest)
			return
		}
		
		if !isImageFileOrDisabled(imageName) {
			http.Error(w, "Not an image file", http.StatusBadRequest)
			return
		}
		
		oldPath := filepath.Join(imageDir, imageName)
		newPath := strings.TrimSuffix(oldPath, ".disabled")
		
		// Check if source file exists
		if _, err := os.Stat(oldPath); os.IsNotExist(err) {
			http.Error(w, "File not found", http.StatusNotFound)
			return
		}
		
		// Rename the file (remove .disabled)
		if err := os.Rename(oldPath, newPath); err != nil {
			log.Printf("Error enabling image %s: %v", imageName, err)
			http.Error(w, fmt.Sprintf("Error enabling image: %v", err), http.StatusInternalServerError)
			return
		}
		
		log.Printf("Enabled image: %s -> %s", imageName, newPath)
		http.Redirect(w, r, "/", http.StatusSeeOther)
	})

	addr := ":" + port
	log.Printf("Starting web server on http://localhost%s", addr)
	return http.ListenAndServe(addr, mux)
}

// startScreensaver starts the screensaver if not in blank window
// @Summary Start screensaver
// @Description Starts the screensaver if it's not currently in the blank window period
// @Tags screensaver
// @Accept json
// @Produce json
// @Success 200 {object} map[string]string "message"
// @Failure 400 {object} map[string]string "error"
// @Router /api/startscreensaver [post]
func startScreensaver(w http.ResponseWriter, r *http.Request, state *ScreensaverState) {
	if r.Method != http.MethodPost {
		http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
		return
	}

	state.mu.RLock()
	inBlank := state.inBlankWindow()
	state.mu.RUnlock()

	if inBlank {
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(http.StatusBadRequest)
		json.NewEncoder(w).Encode(map[string]string{
			"error": "Cannot start screensaver during blank window period",
		})
		return
	}

	state.mu.Lock()
	state.startSaver()
	state.mu.Unlock()

	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(map[string]string{
		"message": "Screensaver started",
	})
}

// stopScreensaver stops the screensaver
// @Summary Stop screensaver
// @Description Stops the screensaver if it's running
// @Tags screensaver
// @Accept json
// @Produce json
// @Success 200 {object} map[string]string "message"
// @Router /api/stopscreensaver [post]
func stopScreensaver(w http.ResponseWriter, r *http.Request, state *ScreensaverState) {
	if r.Method != http.MethodPost {
		http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
		return
	}

	state.mu.Lock()
	state.stopSaver("API request")
	state.mu.Unlock()

	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(map[string]string{
		"message": "Screensaver stopped",
	})
}

func main() {
	// -------- Flags / config --------
	timeoutSec := flag.Int("timeout", 900, "Idle timeout in seconds before screensaver starts")
	touchDevice := flag.String("device", "/dev/input/event5", "Input device node for touch (e.g. /dev/input/event5)")
	imageDir := flag.String("dir", "/home/ralfonso/Pictures/screensaver", "Directory of images for slideshow")
	imvPath := flag.String("imv", "/usr/bin/imv-wayland", "Path to imv-wayland binary")
	imvArgsStr := flag.String("imv-args", "-f -s full -t 30", "Arguments passed to imv-wayland (excluding the directory)")
	logFilePath := flag.String("logfile", "/tmp/screensaver-daemon.log", "Log file path")
	debug := flag.Bool("debug", false, "Enable verbose logging to stdout")

	blankStartStr := flag.String("blank_start", "23:00", "Time of day to begin full blank/off (HH:MM, 24h). Same as blank_end disables blanking.")
	blankEndStr := flag.String("blank_end", "07:00", "Time of day to end full blank/off (HH:MM, 24h)")
	displayOutput := flag.String("output_name", "HDMI-A-1", "Wayland/wlr-randr output name to power off/on")
	webPort := flag.String("web_port", "8087", "Port for the web server (set to empty string to disable)")
	noTouch := flag.Bool("no-touch", false, "Disable touch input monitoring (useful for testing on non-Linux systems)")

	flag.Parse()

	// Derived config
	idleTimeout := time.Duration(*timeoutSec) * time.Second

	blankStartDur, err := parseHHMM(*blankStartStr)
	if err != nil {
		fmt.Fprintf(os.Stderr, "invalid -blank_start: %v\n", err)
		os.Exit(1)
	}
	blankEndDur, err := parseHHMM(*blankEndStr)
	if err != nil {
		fmt.Fprintf(os.Stderr, "invalid -blank_end: %v\n", err)
		os.Exit(1)
	}

	// -------- Logging setup --------
	logFile, err := os.OpenFile(*logFilePath, os.O_CREATE|os.O_WRONLY|os.O_APPEND, 0644)
	if err != nil {
		fmt.Fprintf(os.Stderr, "open log: %v\n", err)
		os.Exit(1)
	}
	defer logFile.Close()

	if *debug {
		log.SetOutput(ioMultiWriter(os.Stdout, logFile))
	} else {
		log.SetOutput(logFile)
	}

	log.Printf("daemon start (timeout=%s device=%s debug=%v blank_start=%s blank_end=%s output=%s web_port=%s)\n",
		idleTimeout, *touchDevice, *debug, *blankStartStr, *blankEndStr, *displayOutput, *webPort)

	// Track last activity
	lastActivity := time.Now()

	// Handle clean shutdown
	stop := make(chan os.Signal, 1)
	signal.Notify(stop, syscall.SIGINT, syscall.SIGTERM)

	// We'll use this channel to avoid blocking on every single touch event
	touchCh := make(chan struct{}, 1)

	// Start libinput to read touch events (if enabled)
	var libinputCmd *exec.Cmd
	var stdout io.ReadCloser
	if !*noTouch {
		libinputCmd = exec.Command("libinput", "debug-events", "--device", *touchDevice)
		var err error
		stdout, err = libinputCmd.StdoutPipe()
		if err != nil {
			log.Fatalf("libinput stdout pipe: %v", err)
		}
		libinputCmd.Stderr = os.Stderr
		if err := libinputCmd.Start(); err != nil {
			log.Fatalf("failed to start libinput: %v", err)
		}
		log.Printf("libinput pid=%d\n", libinputCmd.Process.Pid)
	} else {
		log.Printf("Touch monitoring disabled via -no-touch flag\n")
	}

	// State for our screensaver process
	var saverCmd *exec.Cmd
	saverRunning := false

	// New: screen blank state
	screenBlanked := false

	// --- helpers (moved up so the touch goroutine can call them immediately) ---

	// helper: stop screensaver process if running
	stopSaver := func(reason string) {
		if saverRunning && saverCmd != nil && saverCmd.Process != nil {
			log.Printf("%s -> stop saver pid %d\n", reason, saverCmd.Process.Pid)
			p := saverCmd.Process

			// Try SIGUSR1 first, then TERM, then KILL
			_ = p.Signal(syscall.SIGUSR1)
			done := make(chan error, 1)
			go func(c *exec.Cmd) { done <- c.Wait() }(saverCmd)

			select {
			case <-time.After(300 * time.Millisecond):
				_ = p.Signal(syscall.SIGTERM)
				select {
				case <-time.After(300 * time.Millisecond):
					_ = p.Kill()
				case <-done:
				}
			case <-done:
			}

			saverRunning = false
			saverCmd = nil
		}
	}

	// helper: start screensaver process (if not already running)
	startSaver := func() {
		if saverRunning {
			return
		}
		args := append(splitArgs(*imvArgsStr), *imageDir)
		cmd := exec.Command(*imvPath, args...)
		if err := cmd.Start(); err != nil {
			log.Printf("failed to start screensaver: %v\n", err)
			return
		}
		saverCmd = cmd
		saverRunning = true
		log.Printf("screensaver pid=%d\n", saverCmd.Process.Pid)
	}

	// helper: blank the screen via wlr-randr
	blankScreen := func() {
		if screenBlanked {
			return
		}
		log.Printf("blanking screen via wlr-randr --output %s --off\n", *displayOutput)
		cmd := exec.Command("wlr-randr", "--output", *displayOutput, "--off")
		if err := cmd.Run(); err != nil {
			log.Printf("blankScreen error: %v\n", err)
		}
		screenBlanked = true
	}

	// helper: unblank the screen via wlr-randr
	unblankScreen := func() {
		if !screenBlanked {
			return
		}
		log.Printf("unblanking screen via wlr-randr --output %s --on\n", *displayOutput)
		cmd := exec.Command("wlr-randr", "--output", *displayOutput, "--on")
		if err := cmd.Run(); err != nil {
			log.Printf("unblankScreen error: %v\n", err)
		}
		screenBlanked = false
	}

	// Create screensaver state for API access
	state := &ScreensaverState{
		startSaver: startSaver,
		stopSaver:  stopSaver,
		inBlankWindow: func() bool {
			return inBlankWindow(time.Now(), blankStartDur, blankEndDur)
		},
	}

	// Start web server in goroutine
	if *webPort != "" {
		go func() {
			if err := webServer(*imageDir, *webPort, state); err != nil {
				log.Printf("Web server error: %v\n", err)
			}
		}()
	}

	// Goroutine: read libinput output, update lastActivity (only if touch monitoring enabled)
	if !*noTouch && stdout != nil {
		go func() {
			scanner := bufio.NewScanner(stdout)
			for scanner.Scan() {
				line := scanner.Text()

				// Any libinput line = user activity
				lastActivity = time.Now()

				// If we detect touch while blanked: unblank immediately
				if screenBlanked {
					unblankScreen()
				}

				// NEW: Stop the saver immediately on touch (don't wait for ticker)
				if saverRunning {
					stopSaver("touch activity")
				}

				// poke main loop
				select {
				case touchCh <- struct{}{}:
				default:
				}

				if *debug {
					log.Printf("touch: %s\n", line)
				}
			}
			if err := scanner.Err(); err != nil {
				log.Printf("libinput scanner error: %v\n", err)
			}
		}()
	}

	// Ticker: main loop heartbeat
	ticker := time.NewTicker(1 * time.Second)
	defer ticker.Stop()

	// Extra ticker: for blank-window enforcement
	blankTicker := time.NewTicker(1 * time.Second)
	defer blankTicker.Stop()

loop:
	for {
		select {
		case <-ticker.C:
			now := time.Now()
			idleFor := now.Sub(lastActivity)
			inBlank := inBlankWindow(now, blankStartDur, blankEndDur)

			if inBlank {
				// Night mode
				if saverRunning {
					stopSaver("night blank window active")
				}
				if !screenBlanked {
					blankScreen()
				}
			} else {
				// Day mode
				if screenBlanked {
					unblankScreen()
				}

				// Daytime saver logic
				if idleFor >= idleTimeout && !saverRunning {
					log.Printf("idle_for=%s >= %s -> start screensaver\n", idleFor, idleTimeout)
					startSaver()
				}
				if idleFor < idleTimeout && saverRunning {
					stopSaver(fmt.Sprintf("activity resumed (idle_for=%s < %s)", idleFor, idleTimeout))
				}
			}

		case <-blankTicker.C:
			// Separate ticker enforcing the blank window
			now := time.Now()
			inBlank := inBlankWindow(now, blankStartDur, blankEndDur)
			if inBlank {
				if saverRunning {
					stopSaver("blankTicker night check")
				}
				if !screenBlanked {
					blankScreen()
				}
			} else {
				if screenBlanked {
					unblankScreen()
				}
				// If we've been idle long enough after leaving blank window, start saver
				idleFor := time.Since(lastActivity)
				if idleFor >= idleTimeout && !saverRunning {
					startSaver()
				}
			}

		case <-touchCh:
			// touchCh just nudges the loop; immediate stop already handled in the reader

		case <-stop:
			log.Println("signal -> cleanup")

			// Clean up screensaver if still running
			stopSaver("shutdown")

			// Turn screen back on before exit
			if screenBlanked {
				unblankScreen()
			}

			// Kill libinput process (if it was started)
			if libinputCmd != nil && libinputCmd.Process != nil {
				_ = libinputCmd.Process.Signal(syscall.SIGTERM)
				time.Sleep(200 * time.Millisecond)
				_ = libinputCmd.Process.Kill()
			}

			break loop
		}
	}

	log.Println("exit complete")
}
